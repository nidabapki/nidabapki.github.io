---
layout: protocol
title: Ownership language
name: ownlang
---

<div id="ownLang">

<div class="pageTitle">Язык описания прав доступа</div>

<p>Язык для описания прав доступа называется Ownlang, он позволяет описывать права доступа к следующим операциям связанными со счетом: Bid, PubKeyChange, DisavowKey, DisavowCert и OwnershipChange.</p>

<p>Права доступа описываются при создании счета в поле типа ownership. Это поле состоит из массива данных, которые представляют из себя байткод Ownlang-программы. Ownlang позволяет описать хуки для различных операций, которые будут аутентифицировать операцию. При аутентификации могут использоваться свойства цепочки (например, ставка текущего победителя в аукционе) и свойства проверяемой операции (например, для Bid &mdash; coefficient и список подписей в claim).</p>

<div class="example">
<pre>ownership = {
    n, 
    code : bytecode{n}
}
</pre>
</div>

<p>Программы на языке Ownlang являются чистыми, так как зависят только от состояния цепочки и не изменяют его. Это позволяет при поступлении события (операции) перезапустить Ownlang-программу на момент её добавления, "перемотать" вн. время на текущий момент и совершить проверку (запустить соответствующий операции hook).</p>

<p>При изменении прав доступа с помощью OwnershipChange новый байткод <b>дописывается</b> к предыдущему. Как только приходит сообщение:</p>
<ul>
    <li>цепочка "откатывается" на момент создания счета</li>
    <li>выполняется байткод, определенный при создании счета; контекст выполнения сохраняется</li>
    <li>цепочка "перематывается" на момент добавления OwnershipChange</li>
    <li>новый байткод выполняется в контексте предыдущего выполнения</li>
    <li>цепочка "перематывается" до наших дней</li>
    <li>отрабатывает соответствующий операции hook</li>
</ul>

<p>Так как изменение прав доступа происходит через "дописываение" новой Ownlang-программы к старой, то старая программа может сильно ограничить то, что может делать новая Ownlang-программу.</p>

<h2>Примеры</h2>

<p>Перейдем к рассмотрению примеров.</p>

<p>Если пользователь не описал права доступа, то используются схема по-умолчанию, которая требует подписывать операции ключом сертификата. Пользователь может прописать эту схему явно.</p>

<div class="example">
<pre>setOwnership({
    "*": (context) => {
        assert context.Event.signatures.contains(context.cert.pubKey)
    }
}, [Bid, PubKeyChange, DisavowKey, DisavowCert, OwnershipChange]);
delay(144, [OwnershipChange]);</pre>
</div>

<p>Операция <span class="fun">setOwnership</span> устанавливает права доступа для объектов переданных во втором аргументе. В качестве объектов могут выступать типы описывающие события или внутренние объекты языка, такие как переменые или функции. С каждым объектом может быть несколько операций, например, для событий &mdash; apply (включение события в блок), для переменных &mdash; get и set (изменение значения); как минимум для каждого объекта определена операция <span class="fun">setOwnership</span>, которая может переопределять доступ к этому объекту. Астериск используется для указания всех операций для объекта.</p>

<p><span class="fun">delay</span> добавляет задержку от включения блока до применения. В данном случае добавляется задержка в 2 вн. дня. Если злоумышленник украдет приватный ключ и попытается совершить изменение прав доступа, то у пользователя будет два дня на то, чтобы отозвать сертификат.</p>

<p>Формально, по-умолчанию, доступ к функциям стандартной библиотеки (таких как <span class="fun">delay</span>) не защищается, но выполняться они могут только при создании счета и внутри события OwnershipChange, поэтому фактически для них защита такая же, как и для этих операций.</p>

<p>Настройки доступа по-умолчанию является небезопастными, так как в случае кражи приватного ключа сертификата, пользователю остается только отказаться от сертификата. Для того, чтобы это избежать пользователь может использовать другой ключ для контроля операций (управляющий ключ).</p>

<div class="example">
<pre>setOwnership({
    "*": (context) => {
        assert context.Event.signatures.contains(PK("x42.."))
    }
}, [Bid, PubKeyChange, DisavowKey, DisavowCert, OwnershipChange]);
delay(144, [OwnershipChange]);</pre>
</div>

<p>PK("x42..") &mdash; публичный часть управляющего ключа для доступа к счету. В случае, если злоумышленний получит приватный ключ сертификата, пользователь сможет его сменить. Если злоумышленний получит управляющий приватный ключ &mdash; пользователь отзовет сертификат, как и в случае по-умолчанию.</p>

<p>Вспомним схему A из whitepaper.</p> 

<blockquote>
    An owner of a certificate's account can allow anyone to bid for their sake in a auction. The owner may limit a bid to be no more than 20% above the last bid to prevent a malefactor to make an astronomical bid to sabotage the auction. In addition the owner may deny to make a bid for their sake if they is already the owner of the certificate to avoid the malefactor doing several sequential bids to push the price of ownership higher. Also the owner may limit the bid for their sake to be no more that 5x of base price.
</blockquote>

<p>И опишем её формально с помощью ownlang.</p>

<div class="example">
<pre>owner = PK("x42..")

setOwnership({
    "*": (context) => {
        assert context.Event.signatures.contains(owner);
    }
}, Bid, PubKeyChange, DisavowKey, DisavowCert, OwnershipChange);

setOwnership({
    "apply": (context) => {
        bid = (Bid)context.Event;
        assert bid.auction.winner.bid * 1.20 &ge; bid.bid
        assert bid.auction.winner != bid.account
        assert bid.bid &le; 5
    }
}, Bid);

delay(144, [OwnershipChange]);</pre>
</div>

<p>Во всех примерах выше владелец управляющего ключа обладает полными правами на управление счетом. Давайте ограничем возможность измененять права доступа.</p>

<div class="example">
<pre>setOwnership({
    "*": (context) => {
        assert context.Event.signatures.contains(PK("x42.."));
    }
}, Bid, PubKeyChange, DisavowKey, DisavowCert);

setOwnership({
    "*": (context) => { assert false; }
}, OwnershipChange);</pre>
</div>

<p>После этих изменений никто не сможет включить событие OwnershipChange в блок. В примере опущена задержка <span class="fun">delay</span>, так как ни злоумышленник, ни сам владелец счета не сможет сменить права.</p>

<p>С практической точки зрения этот пример несостоятельный, так как исключает возможность продать сертификат другому пользователю. Давайте добавим возможность менять управляющий ключ, но не тип аутентификации.</p>

<div class="example">
<pre>function changePK(pk) {
    setOwnership({
        "*": (context) => {
            assert context.Event.signatures.contains(pk);
        },
        "setOwnership": (context) => {
            assert context.stackTrace[-1].fun==changePK
        }
    }, Bid, PubKeyChange, DisavowKey, DisavowCert, OwnershipChange);
}
changePK(PK("x42.."));</pre>
</div>

<p>Теперь смена прав доступа ограничена функцией <span class="fun">changePK</span>. Для смены владельца текущий должен опубликовать OwnershipChange с</p>

<p>Этот пример можно переделать для поддержки схемы&nbsp;B, вспомним её:</p>

<blockquote>An owner of a certificate can introduce a list of public keys and
provide access to certificate management operations only if there is a quorum of
keys. Also the list itself may be altered if the quorum is reached. Beside this, a
disavowal of the certificate ownership can be set up to be valid if it is signed by
the quorum of current list or by the quorum of the list which was actual no more
than N blocks ago.</blockquote>

<p>Дополнительно, запретим менять список публичных ключей более, чем на один ключ, а так же проводить изменения чаще, чем раз в день.</p>

<div class="example">
<pre>owners = set([PK("x42.."),PK("y13.."),PK("59k..")])
function changeOwners(pretendents) {
    assert |owners/pretendents| &lt;=1
    assert |pretendents/owners| &lt;=1
    context = getContext()
    if (context.stackTrace[-1].fun.calls.size()>0) {
        assert (
          context.currentBlockNum - 
          context.stackTrace[-1].fun.calls[-1].blockNum
        ) &gt; 72
    }
    owners=pretendents
    setOwnership({
        "*": (context) => {
            assert owners.contains(context.Event.signatures) 
            assert |context.Event.signatures|/|owners|&gt;0.5
        },
        "setOwnership": (context) => {
            assert context.stackTrace[-1].fun==changeOwners
        }
    }, Bid, PubKeyChange, DisavowKey, DisavowCert, OwnershipChange);
}
setOwnership({ "set": (context) => {
    assert context.stackTrace[-1].fun==changeOwners
}}, owners);
changeOwners(owners)</pre>
</div>

<p>Если переменную owners не защитить с помощью setOwnership, то кворум ключей позволил бы включить в блок OwnershipChange, в котором переменная owners могла бы быть изменена в обход условий. Альтернативно мы бы могли использовать идиому IIFE для защиты переменной owners (многоточием показан общий код):</p>


<div class="example">
<pre>changeOwners = (function(owners){
    changeOwners = function (pretendents) {
        ...
    }
    changeOwners(owners)
    return changeOwners;
})(set([PK("x42.."),PK("y13.."),PK("59k..")]));</pre>
</div>

<p>TODO: от размера claim/ownership зависит цена владения домена.</p>

<h2>Изменение описания прав доступа</h2>

<p>Для измения прав доступа используется событие типа OwnershipChange, поле newOwnership представляет  которого</p>

</div>